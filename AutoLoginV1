import logging
import subprocess
import time
import traceback
import warnings
import socket
import re
import urllib.request
import urllib.error
from selenium import webdriver
from selenium.webdriver.common.by import By
from datetime import datetime

# Set up logging
warnings.filterwarnings(action='ignore')
logging.basicConfig(filename='wifi_login.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Define network name (SSID), registration/landing page URLs,
# and login information

network_name = "hotspot@wireless"
# URL templates with placeholders for dynamic MAC and IP
website_link_template = "https://guestaccess-sag.entiretec.com/en/?gwid=66311d085e9cc2f50665d307&vlan=813&mac={mac}&ip={ip}&ori_url=http://www.msftconnecttest.com/redirect"
website_link = ""

# Enter the fields required to login (ex: room #, last name, etc)
accesscode = "myklm-guest-20XX-XX"  # Replace XX with the current month
now = datetime.now()
access_code = f"myklm-guest-{now.year}-{now.month:02d}"

# install required packages
def pip_install(module):
    try:

        print(module + ' module install')
        subprocess.run(['pip', 'install', module], capture_output=True,
                       text=True, creationflags=subprocess.CREATE_NO_WINDOW)

        print(module + ' module install complete')
        return True
    except:
        print(traceback.format_exc())
        return False

try:
    import pandas as pd
except:
    if pip_install('pandas'):
        import pandas as pd
try:
    import subprocess
except:
    if pip_install('subprocess'):
        import subprocess
try:
    import time
except:
    if pip_install('time'):
        import time
try:
    import traceback
except:
    if pip_install('traceback'):
        import traceback
try:
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException
except:
    if pip_install('selenium'):
        from selenium import webdriver
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support.ui import WebDriverWait
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.common.exceptions import TimeoutException
try:
    from webdriver_manager.chrome import ChromeDriverManager
except:
    if pip_install('webdriver-manager'):
        from webdriver_manager.chrome import ChromeDriverManager
    pip_install('chromedriver_autoinstaller')

# function that disconnects from the current wifi
def disconnect_from_current_wifi():
    try:
        # Use the netsh command to disconnect from the connected network
        subprocess.run(['netsh', 'wlan', 'disconnect'], check=True)
        print("Disconnected from the current Wi-Fi network")
        return True
    except subprocess.CalledProcessError as e:
        # log checkpoint
        logging.error( "An error occurred during the disconnection process: %s", e)
        print("Failed to disconnect from the current Wi-Fi network")
        return False

def get_mac_ip_psutil():
    """Get MAC and IP using psutil for hotspot@wireless connection. Returns (mac, ip) or (None, None)."""
    try:
        import psutil
        addrs = psutil.net_if_addrs()
        stats = psutil.net_if_stats()
        
        # First, try to find the specific hotspot@wireless adapter
        for if_name, snic_list in addrs.items():
            # Check if this interface name matches hotspot@wireless (may have slight variations)
            if 'wi-fi' not in if_name.lower():
                continue
            
            st = stats.get(if_name)
            if not st or not st.isup:
                print(f"⚠ Interface '{if_name}' found but is not active (down)")
                continue
            
            mac = None
            ip = None
            for snic in snic_list:
                if hasattr(psutil, 'AF_LINK') and snic.family == psutil.AF_LINK:
                    mac = snic.address
                elif str(snic.family) == 'AddressFamily.AF_LINK':
                    mac = snic.address
                if snic.family == socket.AF_INET:
                    ip = snic.address
            
            if mac and ip:
                print(f"✓ Found hotspot@wireless interface: {if_name} | MAC: {mac} | IP: {ip}")
                return mac, ip
        
        print("ℹ hotspot@wireless not found via psutil, trying ipconfig fallback...")
        return None, None
    except ImportError:
        print("ℹ psutil not installed, trying ipconfig fallback...")
        return None, None
    except Exception as e:
        print(f"✗ Error in get_mac_ip_psutil: {e}")
        return None, None

def get_mac_ip_ipconfig():
    """Get MAC and IP using ipconfig /all for hotspot@wireless. Returns (mac, ip) or (None, None)."""
    try:
        proc = subprocess.run(['ipconfig', '/all'], capture_output=True, text=True)
        text = proc.stdout
        adapter_blocks = re.split(r'\r?\n\r?\n', text)
        for block in adapter_blocks:
            # if 'adapter' not in block.lower():
            #     continue
            # Check if this is the hotspot@wireless adapter
            if 'wi-fi' not in block.lower():
                continue
            phys_match = re.search(r'Physical Address[\.,\s]*: ([\w:-]+)', block, re.IGNORECASE)
            ipv4_match = re.search(r'IPv4 Address[\.,\s]*: ([0-9\.]+)', block, re.IGNORECASE)
            if phys_match and ipv4_match:
                mac = phys_match.group(1).strip().replace('-', ':')
                ip = ipv4_match.group(1).strip().split('(')[0].strip()
                print(f"✓ Found hotspot@wireless interface | MAC: {mac} | IP: {ip}")
                return mac, ip
        print("⚠ hotspot@wireless interface not found in ipconfig output")
        return None, None
    except Exception as e:
        print(f"✗ Error in get_mac_ip_ipconfig: {e}")
        return None, None

def detect_mac_ip():
    """Detect current MAC and IP. Tries psutil first, falls back to ipconfig."""
    mac, ip = get_mac_ip_psutil()
    if not mac or not ip:
        mac, ip = get_mac_ip_ipconfig()
    if mac and ip:
        return mac, ip
    print("✗ Could not detect MAC or IP address")
    return None, None

def is_connected():
    """Quick HTTP probe to check internet connectivity.

    Uses a small lightweight URL that returns 204 (Google's generate_204).
    Returns True if reachable, False otherwise.
    """
    try:
        socket.create_connection(("Google.com", 80))
        # urllib.request.urlopen(test_url, timeout=timeout)
        return True
    except Exception:
        print("✗ No internet connectivity detected")
        return False
    
def login_website():
    try:
        browser = webdriver.Edge(r"C:\Users\haqim\Downloads\edgedriver_win64\msedgedriver.exe")
        browser.get((website_link))
        print("wait to website")
        time.sleep(5)
        ###########################################
        # Find and press the button login access code
        try:
            # Try finding by Class Name first 
            print("find element")
            element4 = browser.find_element(By.CLASS_NAME,"form-container.code_login.py-2")
            print("element found:", element4)
            element4.click()
            print("✓ Button login access code pressed successfully")
        except Exception as e:
            print("✗ Button login access code pressed fail:", e)

        time.sleep(5)

        # Find and fill the access code input
        try:
            # Try finding by ID first (most reliable)
            element = browser.find_element(By.ID,"code_sms_wf")
            print("element found:", element)
            element.clear()
            element.send_keys(access_code)
            print("✓ Access code filled:", access_code)
        except Exception as e:
            print("✗ Access code fill failed:", e)

        # Find and click the accept_terms checkbox
        try:
            # Try finding by Class first (most reliable)
            element2 = browser.find_element(By.CLASS_NAME, "label-text.d-block.small")
            print("element2 found:", element2)
            element2.click()
            print("✓ Checkbox clicked successfully")
        except Exception as e:
            print("✗ Checkbox click failed:", e)

        # Find and click the login button
        try:
            # Try finding by Class first (most reliable)
            element3 = browser.find_element(By.CLASS_NAME, "btn.btn-primary.btn-block")
            print("element3 found:", element3)
            element3.click()
            print("✓ Button pressed successfully")
        except Exception as e:
            print("✗ Button press failed:", e)
        browser.quit()
        ##############################################

        return True
    except Exception as e:
        # log checkpoint
        logging.error("An error occurred during the login process...")
        logging.error(e)
        return False
    
def connect_to_wifi():
    try:
        # Use the netsh command to connect to the desired network
        subprocess.run(['netsh', 'wlan', 'connect',
                       f'name={network_name}'], check=True)
        print(f"Connected to desired Wi-Fi network: '{network_name}'")
        return True
    except subprocess.CalledProcessError as e:
        # log checkpoint
        logging.error(
            f"Failed to connect to '{network_name}' Wi-Fi network. Please check that the connection is available: %s", e)
        print(
            f"Failed to connect to '{network_name}' Wi-Fi network. Please check that the connection is available.")
        return False

# class AutoLogin:
    """Encapsulates AutoLogin behavior so other code can instantiate and call it.

    Methods:
      - detect_mac_ip()
      - is_connected()
      - connect_to_wifi()
      - login_website()
      - start_monitor()
    """

    def __init__(self, network_name: str = network_name, interval: int = 300, probe_url: str = "http://clients3.google.com/generate_204"):
        self.network_name = network_name
        self.interval = interval
        self.probe_url = probe_url
        self.website_link = ""
        self.target_url = ""
        now = datetime.now()
        self.access_code = f"myklm-guest-{now.year}-{now.month:02d}"

    def detect_mac_ip(self):
        return detect_mac_ip()

    def is_connected(self) -> bool:
        return is_connected(self.probe_url)

    def connect_to_wifi(self) -> bool:
        return connect_to_wifi()

    def build_urls(self, mac: str, ip: str):
        self.website_link = website_link_template.format(mac=mac, ip=ip)

    def login_website(self, driver_path: str = None) -> bool:
        """Perform the portal interactions using the instance's `website_link` and `access_code`.
        Returns True on success, False on error.
        """
        try:
            if driver_path:
                browser = webdriver.Edge(driver_path)
            else:
                browser = webdriver.Edge()

            browser.get(self.website_link)
            print("wait to website")
            time.sleep(5)

            # click access-code login button if present
            try:
                print("find element")
                element4 = browser.find_element(By.CSS_SELECTOR, ".form-container.code_login.py-2, .code_login")
                print("element found:", element4)
                element4.click()
                print("✓ Button login access code pressed successfully")
            except Exception as e:
                print("✗ Button login access code pressed fail:", e)

            browser.implicitly_wait(15)

            # Fill code
            try:
                element = browser.find_element(By.ID, "code_sms_wf")
                print("element found:", element)
                element.clear()
                element.send_keys(self.access_code)
                print("✓ Access code filled:", self.access_code)
            except Exception as e:
                print("✗ Access code fill failed:", e)

            # Click checkbox
            try:
                try:
                    element2 = browser.find_element(By.ID, "accept_terms")
                except Exception:
                    element2 = browser.find_element(By.CSS_SELECTOR, "input.accept_terms, input.form-check-input, input[type='checkbox']")
                print("element2 found:", element2)
                element2.click()
                print("✓ Checkbox clicked successfully")
            except Exception as e:
                print("✗ Checkbox click failed:", e)

            # Click submit
            try:
                element3 = None
                for sel in ("button[type='submit']", ".btn.btn-primary.btn-block", "input[type='submit']"):
                    try:
                        element3 = browser.find_element(By.CSS_SELECTOR, sel)
                        break
                    except Exception:
                        continue
                if element3 is not None:
                    print("element3 found:", element3)
                    element3.click()
                    print("✓ Button pressed successfully")
                else:
                    print("✗ Button element not found by common selectors")
            except Exception as e:
                print("✗ Button press failed:", e)

            browser.quit()
            return True
        except Exception as e:
            logging.error("An error occurred during the login process...")
            logging.error(e)
            return False

    def start_monitor(self, driver_path: str = None):
        """Start the periodic connectivity monitor. This blocks until interrupted.
        """
        print("\n[*] Detecting current MAC and IP...")
        mac, ip = self.detect_mac_ip()
        if not mac or not ip:
            print("✗ Failed to detect MAC/IP. Using fallback values.")
            mac = "C0:A8:10:0A:C8:73"
            ip = "10.154.252.166"
        self.build_urls(mac, ip)
        print(f"\n[*] Using URL with detected values:\n    MAC: {mac}\n    IP: {ip}\n    Portal URL: {self.website_link[:80]}...")

        print("\n[*] Starting connectivity monitor (checks every {} seconds). Ctrl-C to stop.".format(self.interval))
        try:
            while True:
                connected = self.is_connected()
                if connected:
                    print("[+] Internet: connected")
                else:
                    print("[-] Internet: disconnected — attempting to reconnect to Wi-Fi...")
                    if self.connect_to_wifi():
                        logging.info("Attempted reconnect to Wi-Fi: success")
                        time.sleep(5)
                        mac, ip = self.detect_mac_ip()
                        if mac and ip:
                            self.build_urls(mac, ip)
                            print(f"    Using MAC {mac} and IP {ip} after reconnect")
                        try:
                            self.login_website(driver_path=driver_path)
                        except Exception as e:
                            print(f"Error during portal login after reconnect: {e}")
                    else:
                        logging.warning("Reconnect attempt failed; will retry")
                # Sleep interval seconds
                for _ in range(self.interval):
                    time.sleep(1)
        except KeyboardInterrupt:
            print("\n[*] Connectivity monitor stopped by user")
            return

def main():
    global website_link
    try:
        # Detect current MAC and IP
        print("\n[*] Detecting current MAC and IP...")
        mac, ip = detect_mac_ip()
        if not mac or not ip:
            print("✗ Failed to detect MAC/IP. Using fallback values.")
            mac = "C0:A8:10:0A:C8:73"
            ip = "10.154.252.166"
        
        # Build URLs with detected MAC and IP
        website_link = website_link_template.format(mac=mac, ip=ip)
        print(f"\n[*] Using URL with detected values:")
        print(f"    MAC: {mac}")
        print(f"    IP: {ip}")
        print(f"    Portal URL: {website_link[:80]}...")
        
        # Start monitoring loop: check connectivity every 5 minutes (300s)
        print("\n[*] Starting connectivity monitor (checks every 5 minutes). Ctrl-C to stop.")
        try:
            while True:
                connected = is_connected()
                if connected:
                    print("[+] Internet: connected")
                else:
                    print("[-] Internet: disconnected — attempting to reconnect to Wi-Fi...")
                    # Try to reconnect to the configured Wi-Fi network
                    if connect_to_wifi():
                        logging.info("Attempted reconnect to Wi-Fi: success")
                        # give network time to settle
                        time.sleep(5)
                        # re-detect MAC/IP (DHCP may have changed IP)
                        mac, ip = detect_mac_ip()
                        if mac and ip:
                            website_link = website_link_template.format(mac=mac, ip=ip)
                            print(f"    Using MAC {mac} and IP {ip} after reconnect")
                        if not is_connected():
                        # Try portal login after reconnect
                            try:
                                login_website()
                            except Exception as e:
                                print(f"Error during portal login after reconnect: {e}")
                    else:
                        logging.warning("Reconnect attempt failed; will retry")
                # Sleep 5 minutes before next check
                for _ in range(300):
                    time.sleep(1)
        except KeyboardInterrupt:
            print("\n[*] Connectivity monitor stopped by user")
            return
    except Exception as e:
        print(f"An error occurred: {e}")


if __name__ == '__main__':
    main()
